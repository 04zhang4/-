# 算法竞赛入门经典
- 算法竞赛的程序应该自做3件事：读入数据，计算结果，打印输出
- 写程序的目的事解决问题，而不是为了写程序而写程序，应保持简单，更好的解决问题
- 用伪代码描述简化算法或者思路
- 注意数据的类型和范围，是否溢出(int 4 32;double 8 64;long long 8 64?)；算术运算溢出和程序效率低下，使用数学方法，观察结果等等方法避免
- `scanf`的返回值是成功接受输入变量的个数
- 建议赋初值，对于存放最大最小数的变量可以将输入的第一个值作为初值，避免出现无限大/小的问题
- 在数组中频繁移动元素是低效的，建议使用链表
- 常常在链表的第一个元素前放入虚拟节点（头节点），方便头部插入
- 可以通过使用数组来模拟链表的功能，这样可以使用数组的标准模板库里的函数

- [算法竞赛入门经典](#算法竞赛入门经典)
  - [3n+1问题](#3n+1问题)
  - [aabb](#aabb)
  - [数据统计](#数据统计)
  - [大理石在哪里](#大理石在哪里)
  - [安迪的第一个字典](#安迪的第一个字典)
  - [集合栈计算机](#集合栈计算机)

## aabb
```c++
#include<bits/stdc++.h>
//输出所有形如aabb的4位完全平方数 
using namespace std;
int main()
{
	for(int a=1;a<=9;a++)
	{
		for(int b=0;b<=9;b++)
		{
			int temp=a*1100+b*11;//sqrt的返回值是double 
			//cout<<sqrt(temp)<<endl;
			if(temp==(int)sqrt(temp) * (int)sqrt(temp))printf("%d\n",temp);
		}
	}
	return 0;
}
```

## 3n+1问题
```c++
#include<bits/stdc++.h>
//输入一个n，若其是奇数，变为3n+1,否则÷2，求经过几次变换为1 
//这里当数据过大会出溢出的风险，所以换成了longlong
using namespace std;
int main()
{
	long long  n=1;
	scanf("%ld",&n);
	int temp=0;
	while(n != 1)
	{
		temp++;
		if(n % 2 == 0)n/=2;
		else n=3*n+1;
		//cout<<n<<endl;
	}
	cout<<temp<<endl;
	return 0;
}
```

## 数据统计
```c++
#include<bits/stdc++.h>
using namespace std;

//输入一行整数，求max。min和average（保留后3位） 
//主要是注意scanf返回值是读取成功的个数，ctrl+z退出

int main()
{
    /*将标准输入输出重定向到对应的文件输入输出
    freopen("data.in","r",stdin);
    freopen("data.out","w",stdout);

    fprintf(&file,...);
    fscanf(&file,....);//文本文件的读写
    */
    //下列是多组输入的情况,后续代码得重新赋初值
    // while(scnaf("%d",&temp) == 1 && temp!=0)
    // {
    //     for(int i=0;i<temp;i++){};
    // }

	int temp=0;
	int sum=0;
	int count=0;
	int max=0;
	int min=0;
	while(scanf("%d",&temp) == 1)
	{
		sum+=temp;
		if(count == 0)
		{
			max=temp;
			min=temp;
		}
		if(temp <= min)min=temp;
		if(temp >= max)max=temp;
		count++;
	}
	double average=(double)sum/(double)count;
	printf("%d %d %0.3lf",max,min,average);
	return 0;
}
```

## 大理石在哪里
```c++
#include<bits/stdc++.h>
using namespace std;
//题目描述，有n个大理石 ，然后有q个整数，判断这q个整数是否在给出得序列中
int area[1000];//预定义一个大容量数组

int main()
{
	fill(area,area+1000,0);
	int num=0,total=0;
	int aim=0;
	while(scanf("%d%d",&num,&total) == 2)//输入的数据
	{
		for(int i=0;i<num;i++)
		{
			scanf("%d",&area[i]);
		}
		sort(area,area+num);//排序
		for(int i=0;i<total;i++)
		{
			scanf("%d",&aim);
			int p=lower_bound(area,area+num,aim)-area;//lower_bound是在升序中，找到第一个大于或等于aim的数，返回对应的地址，再减去第0个的地址就变成了偏移量
			if(area[p] == aim)printf("case %d:\n %d found at %d\n",i+1,aim,p+1);
			else printf("case %d:\n %d not found\n",i+1,aim);
		}
	}
	return 0;
}
```

## 安迪的第一个字典
```c++
#include<bits/stdc++.h>
using namespace std;
int area[1000];//预定义 
//输入一段文本，找出所有不同的单词
int main()
{
	set<string> dict;
	string s;
	while(cin>>s)//持续的读取标准输入流
	{
		for(int i=0;i<s.length();i++)
		{
			if(isalpha(s[i])) s[i]=tolower(s[i]);//将非字母字符转为空格，字母字符转为小写
			else s[i]=' ';
		}
		dict.insert(s);
	}
	for(set<string>::iterator it=dict.begin();it !=dict.end(); ++it)
		cout<<*it<<endl;//迭代器，c98不支持auto智能指针
	return 0;
}
```
## 集合栈计算机
```c++
//该题只是展示stack的用法，以及一些解题思路
// 代码并不完整
// 

#include<bits/stdc++.h>

#define ALL(x) x.begin(),x.end()//所有的内容
#define INS(x) inserter(x,x.begin()) //插入迭代器

 
using namespace std;
//int area[1000];//预定义 
typedef set<int> Set;
stack<int> s;//题目描述的栈，用id标识栈上的每一个集合
 
map<Set,int> IDcache;//用字典储存每一个集合的id映射 
vector<set<int>> Setcache;//根据id储存对应的集合 

int ID(Set x)
{
	//检查该集合是否在映射表中 
	if(IDcache.count(x))return IDcache(x);
	//不在就加入，并返回新id 
	Setcache.push_back(x);
	return IDcache[x]=Setcache.size()-1;
 } 
int main()
{
	int n;
	cin >> n;
	for(int i=0;i<n;i++)
	{
		string op;
		cin >> op;
		if(op[0] == 'P')s.push(ID(Set()));// 进栈空集
		else if (op[0] == 'D')s.push(s.top());
		else 
		{
			Set x1=Setcache[s.top()];
			s.pop();
			Set x2=Setcache[s.top()];
			s.pop();
			Set x;
			if(op[0] == 'U')set_union (ALL(x1),ALL(x2),INS(x));
			if(op[0] == 'I')set_intersection (ALL(x1),ALL(x2),INS(x));
			if(op[0] == 'A')
			{
				x=x2;
				x.insert(ID(x1));
			}
			s.push(ID(x));
		 } 
		 cout<<Setcache[s.top()].size()<<endl;
	}
	return 0;
}

```

## 大整数类：略
```c++
//实际上是自己构造了一个高精度无符号整数的类，并对四则运算，赋值等操作运算符进行重载，暂时略

```

## 破损的键盘（悲剧文本）
```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=100000+5;
int last,cur,next[maxn];
char  s[maxn]
int main()
{
	while(scanf("%s",s+1) ==1)
	{
		int n  = strlen(s+1);
		last=cur=0;
		next[0]=0;

		for(int i=1;i<=n;i++)
		{
			char
		}
	}
}


```
